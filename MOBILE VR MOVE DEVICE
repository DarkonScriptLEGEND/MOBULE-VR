-- LocalScript in StarterPlayerScripts
-- Enhanced VR-like camera control for R6 avatars on mobile using gyroscope (client-side).
-- Camera rotates with device tilt/touch, character position unaffected.
-- Falls back to touch-based rotation if gyroscope unavailable.
-- Uses default R6 arm visuals for hands.

local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")

local player = Players.LocalPlayer
local camera = workspace.CurrentCamera

-- Force first-person mode
player.CameraMode = Enum.CameraMode.LockFirstPerson
print("Camera mode set to first-person")

-- Wait for character
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
print("Character, humanoid, and root part loaded")

-- Lock character movement to prevent camera-driven motion
humanoid.AutoRotate = false
print("Humanoid.AutoRotate disabled to lock character facing")

-- Gyro variables
local initialDeviceCFrame = nil
local lastDeviceCFrame = nil
local gyroEnabled = UserInputService.GyroscopeEnabled
local useGyro = gyroEnabled
local smoothedRotation = CFrame.new()

-- Touch control variables
local touchStart = nil
local lastTouchPos = nil
local yaw = 0
local pitch = 0
local targetYaw = 0
local targetPitch = 0
local sensitivity = 0.005 -- Reduced for smoother touch
local lerpSpeed = 0.2 -- Smoothing factor for both gyro and touch

-- Check gyroscope support
if not gyroEnabled then
    warn("No gyroscope detected. Using touch-based camera control.")
    useGyro = false
else
    print("Gyroscope detected. Enabling VR-like tracking.")
end

-- Reset gyroscope calibration
local function resetInitialRotation()
    if not useGyro then return end
    local success, _, cframe = pcall(UserInputService.GetDeviceRotation, UserInputService)
    if success then
        initialDeviceCFrame = cframe
        lastDeviceCFrame = cframe
        smoothedRotation = CFrame.new()
        print("Gyroscope recalibrated.")
    else
        warn("Failed to calibrate gyroscope. Switching to touch.")
        useGyro = false
    end
end

-- Reset on double-tap
local lastTapTime = 0
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if input.UserInputType == Enum.UserInputType.Touch and not gameProcessed then
        local currentTime = tick()
        if currentTime - lastTapTime < 0.3 then
            if useGyro then
                resetInitialRotation()
            else
                targetYaw = 0
                targetPitch = 0
                yaw = 0
                pitch = 0
                print("Touch rotation reset.")
            end
        end
        lastTapTime = currentTime
    end
end)

-- Touch-based camera control
UserInputService.TouchStarted:Connect(function(input, gameProcessed)
    if not gameProcessed and not useGyro then
        touchStart = input.Position
        lastTouchPos = touchStart
    end
end)

UserInputService.TouchMoved:Connect(function(input, gameProcessed)
    if not gameProcessed and not useGyro and lastTouchPos then
        local delta = input.Position - lastTouchPos
        targetYaw = targetYaw - delta.X * sensitivity
        targetPitch = math.clamp(targetPitch - delta.Y * sensitivity, math.rad(-75), math.rad(75))
        lastTouchPos = input.Position
    end
end)

UserInputService.TouchEnded:Connect(function(input, gameProcessed)
    if not gameProcessed and not useGyro then
        touchStart = nil
        lastTouchPos = nil
    end
end)

-- Update camera
RunService.RenderStepped:Connect(function(dt)
    if player.CameraMode ~= Enum.CameraMode.LockFirstPerson then
        player.CameraMode = Enum.CameraMode.LockFirstPerson
        print("Re-enforced first-person mode.")
    end

    -- Get character's position
    local rootPos = humanoidRootPart.Position + Vector3.new(0, 1.5, 0) -- Head height for R6
    local newRotation

    if useGyro then
        -- Gyroscope-based control
        local success, _, currentCFrame = pcall(UserInputService.GetDeviceRotation, UserInputService)
        if success and initialDeviceCFrame then
            local relativeCFrame = initialDeviceCFrame:Inverse() * currentCFrame
            lastDeviceCFrame = currentCFrame
            local gyroPitch, gyroYaw, gyroRoll = relativeCFrame:ToEulerAnglesYXZ()
            gyroPitch = math.clamp(gyroPitch, math.rad(-75), math.rad(75))
            gyroYaw = math.clamp(gyroYaw, math.rad(-90), math.rad(90))
            gyroRoll = math.clamp(gyroRoll, math.rad(-15), math.rad(15)) -- Reduced roll
            local targetRotation = CFrame.Angles(0, -gyroYaw, 0) * CFrame.Angles(gyroPitch, 0, gyroRoll * 0.5) -- Dampen roll
            smoothedRotation = smoothedRotation:Lerp(targetRotation, lerpSpeed)
            newRotation = smoothedRotation
            print("Gyro updating: Pitch=" .. math.deg(gyroPitch) .. ", Yaw=" .. math.deg(gyroYaw))
        else
            warn("Gyro failed in RenderStepped. Switching to touch.")
            useGyro = false
        end
    else
        -- Touch-based control with smoothing
        yaw = yaw + (targetYaw - yaw) * lerpSpeed
        pitch = pitch + (targetPitch - pitch) * lerpSpeed
        newRotation = CFrame.Angles(0, -yaw, 0) * CFrame.Angles(pitch, 0, 0)
        print("Touch updating: Pitch=" .. math.deg(pitch) .. ", Yaw=" .. math.deg(yaw))
    end

    -- Update camera
    camera.CFrame = CFrame.new(rootPos) * newRotation
end)

-- Handle character respawn
player.CharacterAdded:Connect(function(newCharacter)
    character = newCharacter
    humanoid = character:WaitForChild("Humanoid")
    humanoidRootPart = character:WaitForChild("HumanoidRootPart")
    humanoid.AutoRotate = false
    print("Character respawned.")
    if useGyro then
        resetInitialRotation()
    end
end)

-- Initial calibration
if useGyro then
    resetInitialRotation()
end
