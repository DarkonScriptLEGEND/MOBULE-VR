-- LocalScript in StarterPlayerScripts
-- Enhanced VR-like camera control for R6 avatars on mobile using gyroscope (client-side).
-- Camera rotates with device tilt, character position unaffected.
-- Falls back to touch-based rotation if gyroscope unavailable.
-- Uses default R6 arm visuals for hands.

local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")

local player = Players.LocalPlayer
local camera = workspace.CurrentCamera

-- Force first-person mode
player.CameraMode = Enum.CameraMode.LockFirstPerson
print("Camera mode set to first-person")

-- Wait for character
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
print("Character, humanoid, and root part loaded")

-- Lock character movement
humanoid.AutoRotate = false
print("Humanoid.AutoRotate disabled to lock character facing")

-- Gyro variables
local initialDeviceCFrame = nil
local gyroEnabled = UserInputService.GyroscopeEnabled
local useGyro = gyroEnabled
local smoothedRotation = CFrame.new()
local lerpSpeed = 0.3 -- Increased for smoother tracking
local gyroSensitivity = 1.5 -- Amplify gyro response

-- Touch control variables
local touchStart = nil
local lastTouchPos = nil
local yaw = 0
local pitch = 0
local targetYaw = 0
local targetPitch = 0
local touchSensitivity = 0.004 -- Finer touch control

-- Check gyroscope support
if not gyroEnabled then
    warn("No gyroscope detected. Using touch-based camera control.")
    useGyro = false
else
    print("Gyroscope detected. Enabling VR-like tracking.")
end

-- Reset gyroscope calibration
local function resetInitialRotation()
    if not useGyro then return end
    local success, _, cframe = pcall(UserInputService.GetDeviceRotation, UserInputService)
    if success then
        initialDeviceCFrame = cframe
        smoothedRotation = CFrame.new()
        print("Gyroscope recalibrated. Initial orientation set.")
    else
        warn("Failed to calibrate gyroscope. Switching to touch.")
        useGyro = false
    end
end

-- Reset on double-tap
local lastTapTime = 0
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if input.UserInputType == Enum.UserInputType.Touch and not gameProcessed then
        local currentTime = tick()
        if currentTime - lastTapTime < 0.3 then
            if useGyro then
                resetInitialRotation()
            else
                targetYaw = 0
                targetPitch = 0
                yaw = 0
                pitch = 0
                print("Touch rotation reset.")
            end
        end
        lastTapTime = currentTime
    end
end)

-- Touch-based camera control
UserInputService.TouchStarted:Connect(function(input, gameProcessed)
    if not gameProcessed and not useGyro then
        touchStart = input.Position
        lastTouchPos = touchStart
    end
end)

UserInputService.TouchMoved:Connect(function(input, gameProcessed)
    if not gameProcessed and not useGyro and lastTouchPos then
        local delta = input.Position - lastTouchPos
        targetYaw = targetYaw - delta.X * touchSensitivity
        targetPitch = math.clamp(targetPitch - delta.Y * touchSensitivity, math.rad(-80), math.rad(80))
        lastTouchPos = input.Position
    end
end)

UserInputService.TouchEnded:Connect(function(input, gameProcessed)
    if not gameProcessed and not useGyro then
        touchStart = nil
        lastTouchPos = nil
    end
end)

-- Update camera
RunService.RenderStepped:Connect(function(dt)
    if player.CameraMode ~= Enum.CameraMode.LockFirstPerson then
        player.CameraMode = Enum.CameraMode.LockFirstPerson
        print("Re-enforced first-person mode.")
    end

    -- Get character's position
    local rootPos = humanoidRootPart.Position + Vector3.new(0, 1.5, 0) -- Head height for R6
    local newRotation

    if useGyro then
        -- Gyroscope-based control
        local success, _, currentCFrame = pcall(UserInputService.GetDeviceRotation, UserInputService)
        if success and initialDeviceCFrame then
            -- Compute relative rotation
            local relativeCFrame = initialDeviceCFrame:Inverse() * currentCFrame
            local gyroPitch, gyroYaw, gyroRoll = relativeCFrame:ToEulerAnglesYXZ()
            gyroPitch = math.clamp(gyroPitch * gyroSensitivity, math.rad(-80), math.rad(80))
            gyroYaw = gyroYaw * gyroSensitivity
            gyroRoll = 0 -- Remove roll for stability
            local targetRotation = CFrame.Angles(0, -gyroYaw, 0) * CFrame.Angles(gyroPitch, 0, 0)
            smoothedRotation = smoothedRotation:Lerp(targetRotation, lerpSpeed)
            newRotation = smoothedRotation
            print(string.format("Gyro: Pitch=%.2f, Yaw=%.2f, Roll=%.2f", math.deg(gyroPitch), math.deg(gyroYaw), math.deg(gyroRoll)))
        else
            warn("Gyro failed in RenderStepped. Switching to touch.")
            useGyro = false
        end
    else
        -- Touch-based control with smoothing
        yaw = yaw + (targetYaw - yaw) * lerpSpeed
        pitch = pitch + (targetPitch - pitch) * lerpSpeed
        newRotation = CFrame.Angles(0, -yaw, 0) * CFrame.Angles(pitch, 0, 0)
        print(string.format("Touch: Pitch=%.2f, Yaw=%.2f", math.deg(pitch), math.deg(yaw)))
    end

    -- Update camera
    camera.CFrame = CFrame.new(rootPos) * newRotation
end)

-- Handle character respawn
player.CharacterAdded:Connect(function(newCharacter)
    character = newCharacter
    humanoid = character:WaitForChild("Humanoid")
    humanoidRootPart = character:WaitForChild("HumanoidRootPart")
    humanoid.AutoRotate = false
    print("Character respawned.")
    if useGyro then
        resetInitialRotation()
    end
end)

-- Initial calibration
if useGyro then
    resetInitialRotation()
end
